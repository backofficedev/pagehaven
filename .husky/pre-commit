#!/bin/sh

# Exit on any error (but we handle cleanup manually)

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)

# Track if we created a stash
STASH_CREATED=0

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
if [ -n "$(git diff --name-only)" ]; then
  git stash push --quiet --keep-index --message "pre-commit-stash"
  STASH_CREATED=1
fi

# Function to restore stash and exit with given code
cleanup_and_exit() {
  EXIT_CODE=$1
  
  if [ $STASH_CREATED -eq 1 ]; then
    echo "üîÑ Restoring working directory state..."
    git stash pop --quiet || true
  fi
  
  exit $EXIT_CODE
}

# Run formatter on the staged files
bun x ultracite fix
FORMAT_EXIT_CODE=$?

if [ $FORMAT_EXIT_CODE -ne 0 ]; then
  echo "‚ùå Formatting failed"
  cleanup_and_exit $FORMAT_EXIT_CODE
fi

# Run type check (fast with turbo caching)
echo "üîç Running type check..."
bun run check-types --ui=stream
TYPES_EXIT_CODE=$?

if [ $TYPES_EXIT_CODE -ne 0 ]; then
  echo "‚ùå Type check failed"
  cleanup_and_exit $TYPES_EXIT_CODE
fi

# Run tests (fast with turbo caching)
echo "üß™ Running tests..."
bun run test --ui=stream
TEST_EXIT_CODE=$?

if [ $TEST_EXIT_CODE -ne 0 ]; then
  echo "‚ùå Tests failed"
  cleanup_and_exit $TEST_EXIT_CODE
fi

# Run knip for unused code detection
echo "üîé Running knip..."
bunx knip
KNIP_EXIT_CODE=$?

if [ $KNIP_EXIT_CODE -ne 0 ]; then
  echo "‚ùå Knip found issues"
  cleanup_and_exit $KNIP_EXIT_CODE
fi

# Run copy-paste detection
echo "üìã Running copy-paste detection..."
bun run cpd
CPD_EXIT_CODE=$?

if [ $CPD_EXIT_CODE -ne 0 ]; then
  echo "‚ùå Copy-paste detection found issues"
  cleanup_and_exit $CPD_EXIT_CODE
fi

# All checks passed - re-stage formatted files
if [ -n "$STAGED_FILES" ]; then
  echo "$STAGED_FILES" | while IFS= read -r file; do
    if [ -f "$file" ]; then
      git add "$file"
    fi
  done
fi

# Restore unstaged changes
if [ $STASH_CREATED -eq 1 ]; then
  git stash pop --quiet || true
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "‚ú® Files formatted by Ultracite"
fi

exit 0
